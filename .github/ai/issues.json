{
  "_metadata": {
    "description": "A collection of GitHub issues for the stbl repository.",
    "lookup_key": "issue_number",
    "comment": "Each key in the 'issues' object is a string representation of the GitHub issue number. Empty objects are placeholders so that positions and ids match. Empty objects should be ignored."
  },
  "issues": {
    "1": [],
    "2": [],
    "3": [],
    "4": [],
    "5": [],
    "6": [],
    "7": [],
    "8": {
      "title": "`named` arg",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add an argument to all `stabilize_*()` functions, `named`, with default value `NULL` or maybe `NA`. Its behavior depends on its value:\n\n- `NULL` or `NA` or `character(0)`: Don't check names.\n- `TRUE`: Object must be named, but we don't care what the values are.\n- `FALSE`: Object must not be named.\n- character vector: Object must have these names. Technically it's \"the object must `rlang::is_named2(x), and all names of object must be in this vector\", because we aren't checking length specifically via this argument.\n\nI don't like that I cant stabilize this argument, but this is the best pattern I can think of for interpretation.",
      "comments": {}
    },
    "9": [],
    "10": [],
    "11": [],
    "12": [],
    "13": [],
    "14": [],
    "15": [],
    "16": [],
    "17": [],
    "18": [],
    "19": [],
    "20": [],
    "21": [],
    "22": [],
    "23": [],
    "24": [],
    "25": [],
    "26": {
      "title": "stabilize_names()",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "A more complete stabilizer that can confirm precise names, or no duplicates, or that certain names are present, etc.",
      "comments": {}
    },
    "27": [],
    "28": [],
    "29": [],
    "30": [],
    "31": [],
    "32": [],
    "33": [],
    "34": [],
    "35": [],
    "36": [],
    "37": [],
    "38": [],
    "39": [],
    "40": [],
    "41": [],
    "42": [],
    "43": [],
    "44": {
      "title": "Export stabilize_cls()?",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "As a developer, I'd like to implement a stbl-style checker for my fancy new class, so that users can get informative error messages for broken bits.\r\n\r\nSee how necessary this is after finishing vctrs setup.",
      "comments": {}
    },
    "45": [],
    "46": [],
    "47": [],
    "48": [],
    "49": [],
    "50": [],
    "51": [],
    "52": [],
    "53": [],
    "54": [],
    "55": [],
    "56": [],
    "57": [],
    "58": [],
    "59": [],
    "60": [],
    "61": [],
    "62": [],
    "63": [],
    "64": [],
    "65": [],
    "66": {
      "title": "Quotes around bad values in to_fct",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "There's a cli decorator to automatically put `\" \"` around the `Bad values:` list. Do that.",
      "comments": {}
    },
    "67": [],
    "68": [],
    "69": [],
    "70": [],
    "71": [],
    "72": [],
    "73": [],
    "74": [],
    "75": [],
    "76": [],
    "77": [],
    "78": [],
    "79": [],
    "80": {
      "title": "JSON schema tix",
      "type": {
        "id": 29398100,
        "node_id": "IT_kwDODjbzj84BwJRU",
        "name": "Task",
        "description": "A specific piece of work",
        "color": "yellow",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Make tickets for all the json sch√©ma-recognized field types. That's really what this package is about, lean into it. Some might involve packages in Suggests (eg, don't import clock/lubridate if people don't care about dates, probably something similar for urls). ",
      "comments": {}
    },
    "81": [],
    "82": [],
    "83": [],
    "84": [],
    "85": [],
    "86": [],
    "87": [],
    "88": [],
    "89": [],
    "90": [],
    "91": [],
    "92": [],
    "93": [],
    "94": [],
    "95": [],
    "96": [],
    "97": [],
    "98": [],
    "99": [],
    "100": [],
    "101": [],
    "102": [],
    "103": [],
    "104": {
      "title": "Stabilize dates",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add `to_date()` etc. Will probably use `base::as.Date()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": {}
    },
    "105": {
      "title": "Stabilize date-times",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add `to_dttm()` etc. Will probably use `base::as.POSIXct()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": {}
    },
    "106": [],
    "107": [],
    "108": [],
    "109": [],
    "110": {
      "title": "Implement `stabilize_list()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "(Issue created via conversation with a stbl \"expert\" gem on Google Gemini)\n\n## Overview\n\nWe should add a `stabilize_list()` function family (`stabilize_list`, `to_list`, `are_list_ish`, etc.) to `{stbl}`. The primary purpose of this family would be to validate the structure and contents of lists, which is a common requirement for functions that accept complex configuration objects.\n\n## API Design\n\nThe key challenge is creating an API that is both powerful enough to handle complex, nested, and heterogeneous lists, but simple enough that it doesn't require users to write complex wrappers or use non-standard syntax like `quote()`.\n\nThe proposed API distinguishes between checks on the list container and checks on the list elements.\n\n1. Container Checks: Arguments prefixed with a `.` (e.g., `.min_size`, `.allow_named = TRUE`) will apply to the list object itself.\n2. Element Checks: Unprefixed arguments passed via `...` will define the validation rules for the elements within the list. These arguments should accept `purrr`-style anonymous functions (`~ .x`).\n\n## Proposed Syntax\n\n```r\nstabilize_list(\n  x,\n  ..., # Named arguments are purrr-style formulas for named elements\n  .default = NULL, # A default formula for unspecified/unnamed elements\n  .min_size = NULL,\n  .max_size = NULL\n  # ... other potential container checks\n)\n```\n\n## Concrete Use Case\n\nA function that builds a plot specification could use `stabilize_list` to validate its main argument:\n\n```r\ncreate_plot_spec <- function(spec) {\n  spec <- stabilize_list(\n    spec,\n    # --- Schema for list elements (using formulas) ---\n    title = ~ stabilize_chr_scalar(.x, allow_null = FALSE),\n    data = ~ stabilize_arg(.x, allow_null = FALSE),\n    aesthetics = ~ stabilize_list(\n      .x,\n      x = ~ stabilize_chr_scalar(.x),\n      y = ~ stabilize_chr_scalar(.x),\n      .min_size = 2,\n      .max_size = 2\n    ),\n    # --- Rules for the list container itself ---\n    .min_size = 3,\n    .max_size = 3\n  )\n\n  # ... function logic now operates on a guaranteed-valid spec object ...\n  return(spec)\n}\n```\n\n## Acceptance Criteria\n\n- Create the `stabilize_list` function family with corresponding `to_list` and `are_list_ish` functions and tests.\n- The implementation must support validation of both homogeneous and heterogeneous lists via the formula syntax.\n- The implementation must support both named and unnamed lists.\n- Error messages must be informative, clearly indicating which element of which list failed validation and providing the underlying error from the specific stabilizer that failed.\n",
      "comments": "Make the main function `stabilize_lst()` (etc), and implement `stabilize_list()` (etc) as aliases, I think. Depending how clean that is, consider writing tickets for more aliases, like `stabilize_character()`."
    },
    "111": [],
    "112": [],
    "113": [],
    "114": [],
    "115": [],
    "116": [],
    "117": [],
    "118": [],
    "119": [],
    "120": [],
    "121": [],
    "122": [],
    "123": [],
    "124": [],
    "125": [],
    "126": [],
    "127": [],
    "128": [],
    "129": [],
    "130": [],
    "131": [],
    "132": [],
    "133": [],
    "134": [],
    "135": [],
    "136": [],
    "137": [],
    "138": [],
    "139": [],
    "140": [],
    "141": [],
    "142": {
      "title": "Implement `stabilize_df()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "> As a {stbl} user, in order to validate the structure and content of a data frame, I would like a `stabilize_df()` function.\n\nThis function will serve as a wrapper around `stabilize_lst()` (#110) to provide specialized checks for data frames. The function should first verify that the input is a data frame and then use `stabilize_lst()` to apply stabilization rules to each column.\n\nKey features should include:\n\n* **Column stabilization**: Use a named list of stabilization functions to apply to each column.\n* **Dimension checks**: Parameters to specify the expected number of rows and columns.\n* **Column name checks**: A parameter to ensure that all expected column names are present.\n\nI can imagine an argument to specify what to do with columns that are too short, but I need to conceptualize how that will work and find examples. Check {tidyr}.",
      "comments": {}
    },
    "143": [],
    "144": [],
    "145": [],
    "146": [],
    "147": {
      "title": "Implement `specify_chr()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "> As a {stbl} user, in order to describe how character vectors should appear in larger contexts like lists or data frames, I would like to create re-usable and readable validation rules for character vectors (via a `specify_chr()` function).\n\nThis ticket introduces the `specify_chr()` function, which will be the first of the new `specify_*()` family. These functions will serve as helper functions (or \"specification builders\") that make it easier to define validation schemas for `stabilize_list()` and `stabilize_df()`.\n\nThe `specify_chr()` function should have a signature that mirrors its `stabilize_chr()` counterpart (e.g., accepting arguments like `allow_null`, `allow_na`, `min_len`, `max_len`, `min_nchar`, etc.).\n\nInstead of performing validation itself, this function will capture its arguments and return a function. This function can then be passed directly into `stabilize_list()` or `stabilize_df()`, or called directly on an argument.\n\nAlso create the scalar variant (`specify_chr_scalar()`).\n\n## Example of Use\n\nSpecify rules for a character vector:\n\n```r\nspec <- specify_chr(allow_null = TRUE, max_len = 10)\n```\n\nUse those rules directly:\n\n```r\n# equivalent to stabilize(letters, allow_null = TRUE, max_len = 10)\nspec(letters)\n```\n\nUse those rules to specify a list (after #110):\n\n```r\nstabilize_list(my_list, names = spec)\n```\n\n## Acceptance Criteria\n\n- `specify_chr()` function exists.\n- `specify_chr_scalar()` function exists.\n- The functions must accept all arguments from their `stabilize_chr()` counterparts.\n- The functions must return functions that call `stabilize_chr()` or `stabilize_chr_scalar()` with the provided arguments (in the proper environment).\n",
      "comments": {}
    },
    "148": {
      "title": "Implement `specify_dbl()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "Build on #147 for doubles.",
      "comments": {}
    },
    "149": {
      "title": "Implement `specify_int()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "Build on #147 for integers.",
      "comments": {}
    },
    "150": {
      "title": "Implement `specify_fct()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "Build on #147 for factors.",
      "comments": {}
    },
    "151": {
      "title": "Implement `specify_lgl()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "Build on #147 for logical vectors.",
      "comments": {}
    }
  }
}
