{
  "_metadata": {
    "description": "A collection of GitHub issues for the stbl repository.",
    "lookup_key": "issue_number",
    "comment": "Each key in the 'issues' object is a string representation of the GitHub issue number."
  },
  "issues": {
    "1": [],
    "2": [],
    "3": [],
    "4": [],
    "5": [],
    "6": [],
    "7": [],
    "8": {
      "title": "has_names arg",
      "comments": {},
      "body": "Scalar logical. A separate function will deal with more complex cases.",
      "milestone": 4
    },
    "9": {
      "title": "Wrapper to switch on type?",
      "comments": {},
      "body": "If an arg can have two types (length-1 logical vs character vector as in the \"has_names\" ticket I just submitted as #8), should we have a function to deal with those? Do we coerce at all? Maybe something that throws an error if it isn't coercible to either? Or encourage people to make S3s to handle those?",
      "milestone": 4
    },
    "10": [],
    "11": [],
    "12": [],
    "13": [],
    "14": [],
    "15": [],
    "16": [],
    "17": [],
    "18": [],
    "19": [],
    "20": [],
    "21": [],
    "22": [],
    "23": [],
    "24": [],
    "25": [],
    "26": {
      "title": "stabilize_names()",
      "comments": {},
      "body": "A more complete stabilizer that can confirm precise names, or no duplicates, or that certain names are present, etc.",
      "milestone": 5
    },
    "27": [],
    "28": [],
    "29": {
      "title": "to_lgl.int() options",
      "comments": {},
      "body": "coerce_int argument, or something else? If it looks like the chr and fctr arguments in to_int, then it should be logical scalar. If I want a family of choices (something like \"always\", \"never\", \"01\"), I should think of a different arg name.",
      "milestone": 4
    },
    "30": {
      "title": "to_lgl.character(): \"0\" and \"1\"",
      "comments": {},
      "body": "Should \"0\" and \"1\" cast to FALSE and TRUE? Should ANY integer? Behind a flag?",
      "milestone": 4
    },
    "31": {
      "title": "to_lgl.double() options",
      "comments": {},
      "body": "By default, we accept `1.1` as TRUE. Add an argument to make it stricter?",
      "milestone": 4
    },
    "32": [],
    "33": {
      "title": "Export to_null()",
      "comments": {},
      "body": "Is this anything?",
      "milestone": 4
    },
    "34": [],
    "35": [],
    "36": [],
    "37": {
      "title": "allow_empty in stabilize_chr()",
      "comments": {},
      "body": "Allow user to reject \"\"",
      "milestone": 4
    },
    "38": [],
    "39": [],
    "40": [],
    "41": [],
    "42": {
      "title": "Update usage",
      "comments": "Pausing to actually use stbl in a package before writing about how I imagine it will be used.",
      "body": "Clean up the info in the Readme and add a main usage vignette for pkgdown. ",
      "milestone": 4
    },
    "43": [],
    "44": {
      "title": "Export stabilize_cls()?",
      "comments": {},
      "body": "As a developer, I'd like to implement a stbl-style checker for my fancy new class, so that users can get informative error messages for broken bits.\r\n\r\nSee how necessary this is after finishing vctrs setup.",
      "milestone": 4
    },
    "45": [],
    "46": [],
    "47": [],
    "48": [],
    "49": [],
    "50": [],
    "51": [],
    "52": [],
    "53": [],
    "54": [],
    "55": [],
    "56": [],
    "57": [],
    "58": [],
    "59": [],
    "60": [],
    "61": [],
    "62": [],
    "63": [],
    "64": [],
    "65": [],
    "66": {
      "title": "Quotes around bad values in to_fct",
      "comments": {},
      "body": "There's a cli decorator to automatically put `\" \"` around the `Bad values:` list. Do that.",
      "milestone": 5
    },
    "67": {
      "title": "to_fct: Enumerate options",
      "comments": {},
      "body": "For `to_fct()`, the error message says \"All values of `location` must be present in `levels` or `to_na`.\"\r\n\r\nWhen those are fixed values, the user doesn't know what `levels` and `to_na` are referring to.\r\nInstead give the list of acceptable values (potentially pointing out the ones that will be treated as NA).",
      "milestone": 4
    },
    "68": [],
    "69": [],
    "70": [],
    "71": [],
    "72": [],
    "73": [],
    "74": [],
    "75": [],
    "76": [],
    "77": [],
    "78": [],
    "79": [],
    "80": {
      "title": "JSON schema tix",
      "comments": {},
      "body": "Make tickets for all the json sch√©ma-recognized field types. That's really what this package is about, lean into it. Some might involve packages in Suggests (eg, don't import clock/lubridate if people don't care about dates, probably something similar for urls). ",
      "milestone": 5
    },
    "81": {
      "title": "Migrate to api2r organization?",
      "comments": "This exists because of api2r, though, and it's about function APIs, so... yeah, probably api2r is fine.",
      "body": "In order to organize things better and take advantage of additional GitHub features, as the lead developer of these packages, I would like to wrap them up into the api2r organization.\n\nI'm not 100% certain that this one belongs in api2r. Maybe I need a github org for my R packages that don't have a \"family\"?",
      "milestone": 4
    },
    "82": [],
    "83": [],
    "84": [],
    "85": [],
    "86": [],
    "87": [],
    "88": [],
    "89": [],
    "90": [],
    "91": [],
    "92": [],
    "93": [],
    "94": [],
    "95": [],
    "96": {
      "title": "Refine error subclasses",
      "comments": {},
      "body": "The `to_int.character()` method has two distinct failure modes (incompatible values and loss of precision) that could benefit from more specific error subclasses.\n\nSimilar to to_int(), the coercion functions for logicals could have more specific error subclasses for different failure types.\n",
      "milestone": 4
    },
    "97": [],
    "98": [],
    "99": [],
    "100": [],
    "101": [],
    "102": [],
    "103": [],
    "104": {
      "title": "Stabilize dates",
      "comments": {},
      "body": "Add `to_date()` etc. Will probably use `base::as.Date()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "milestone": 5
    },
    "105": {
      "title": "Stabilize date-times",
      "comments": {},
      "body": "Add `to_dttm()` etc. Will probably use `base::as.POSIXct()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "milestone": 5
    },
    "106": [],
    "107": [],
    "108": [],
    "109": [],
    "110": {
      "title": "Implement `stabilize_list()`",
      "comments": {},
      "body": "(Issue created via conversation with a stbl \"expert\" gem on Google Gemini)\n\n## Overview\n\nWe should add a `stabilize_list()` function family (`stabilize_list`, `to_list`, `are_list_ish`, etc.) to `{stbl}`. The primary purpose of this family would be to validate the structure and contents of lists, which is a common requirement for functions that accept complex configuration objects.\n\n## API Design\n\nThe key challenge is creating an API that is both powerful enough to handle complex, nested, and heterogeneous lists, but simple enough that it doesn't require users to write complex wrappers or use non-standard syntax like `quote()`.\n\nThe proposed API distinguishes between checks on the list container and checks on the list elements.\n\n1. Container Checks: Arguments prefixed with a `.` (e.g., `.min_size`, `.allow_named = TRUE`) will apply to the list object itself.\n2. Element Checks: Unprefixed arguments passed via `...` will define the validation rules for the elements within the list. These arguments should accept `purrr`-style anonymous functions (`~ .x`).\n\n## Proposed Syntax\n\n```r\nstabilize_list(\n  x,\n  ..., # Named arguments are purrr-style formulas for named elements\n  .default = NULL, # A default formula for unspecified/unnamed elements\n  .min_size = NULL,\n  .max_size = NULL\n  # ... other potential container checks\n)\n```\n\n## Concrete Use Case\n\nA function that builds a plot specification could use `stabilize_list` to validate its main argument:\n\n```r\ncreate_plot_spec <- function(spec) {\n  spec <- stabilize_list(\n    spec,\n    # --- Schema for list elements (using formulas) ---\n    title = ~ stabilize_chr_scalar(.x, allow_null = FALSE),\n    data = ~ stabilize_arg(.x, allow_null = FALSE),\n    aesthetics = ~ stabilize_list(\n      .x,\n      x = ~ stabilize_chr_scalar(.x),\n      y = ~ stabilize_chr_scalar(.x),\n      .min_size = 2,\n      .max_size = 2\n    ),\n    # --- Rules for the list container itself ---\n    .min_size = 3,\n    .max_size = 3\n  )\n\n  # ... function logic now operates on a guaranteed-valid spec object ...\n  return(spec)\n}\n```\n\n## Acceptance Criteria\n\n- Create the `stabilize_list` function family with corresponding `to_list` and `are_list_ish` functions and tests.\n- The implementation must support validation of both homogeneous and heterogeneous lists via the formula syntax.\n- The implementation must support both named and unnamed lists.\n- Error messages must be informative, clearly indicating which element of which list failed validation and providing the underlying error from the specific stabilizer that failed.\n",
      "milestone": 5
    }
  }
}
