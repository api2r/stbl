{
  "_metadata": {
    "description": "A collection of GitHub issues for the stbl repository.",
    "lookup_key": "issue_number",
    "comment": "Each key in the 'issues' object is a string representation of the GitHub issue number. Empty objects are placeholders so that positions and ids match. Empty objects should be ignored."
  },
  "issues": {
    "1": [],
    "2": [],
    "3": [],
    "4": [],
    "5": [],
    "6": [],
    "7": [],
    "8": {
      "title": "`named` arg",
      "type": {},
      "milestone": 5,
      "body": "Add an argument to all `stabilize_*()` functions, `named`, with default value `NULL` or maybe `NA`. Its behavior depends on its value:\n\n- `NULL` or `NA` or `character(0)`: Don't check names.\n- `TRUE`: Object must be named, but we don't care what the values are.\n- `FALSE`: Object must not be named.\n- character vector: Object must have these names. Technically it's \"the object must `rlang::is_named2(x), and all names of object must be in this vector\", because we aren't checking length specifically via this argument.\n\nI don't like that I cant stabilize this argument, but this is the best pattern I can think of for interpretation.",
      "comments": {}
    },
    "9": [],
    "10": [],
    "11": [],
    "12": [],
    "13": [],
    "14": [],
    "15": [],
    "16": [],
    "17": [],
    "18": [],
    "19": [],
    "20": [],
    "21": [],
    "22": [],
    "23": [],
    "24": [],
    "25": [],
    "26": {
      "title": "stabilize_names()",
      "type": {},
      "milestone": 5,
      "body": "A more complete stabilizer that can confirm precise names, or no duplicates, or that certain names are present, etc.",
      "comments": {}
    },
    "27": [],
    "28": [],
    "29": [],
    "30": [],
    "31": [],
    "32": [],
    "33": [],
    "34": [],
    "35": [],
    "36": [],
    "37": [],
    "38": [],
    "39": [],
    "40": [],
    "41": [],
    "42": [],
    "43": [],
    "44": {
      "title": "Export stabilize_cls()?",
      "type": {},
      "milestone": 5,
      "body": "As a developer, I'd like to implement a stbl-style checker for my fancy new class, so that users can get informative error messages for broken bits.\r\n\r\nSee how necessary this is after finishing vctrs setup.",
      "comments": {}
    },
    "45": [],
    "46": [],
    "47": [],
    "48": [],
    "49": [],
    "50": [],
    "51": [],
    "52": [],
    "53": [],
    "54": [],
    "55": [],
    "56": [],
    "57": [],
    "58": [],
    "59": [],
    "60": [],
    "61": [],
    "62": [],
    "63": [],
    "64": [],
    "65": [],
    "66": {
      "title": "Quotes around bad values in to_fct",
      "type": {},
      "milestone": 5,
      "body": "There's a cli decorator to automatically put `\" \"` around the `Bad values:` list. Do that.",
      "comments": {}
    },
    "67": [],
    "68": [],
    "69": [],
    "70": [],
    "71": [],
    "72": [],
    "73": [],
    "74": [],
    "75": [],
    "76": [],
    "77": [],
    "78": [],
    "79": [],
    "80": {
      "title": "JSON schema tix",
      "type": {},
      "milestone": 5,
      "body": "Make tickets for all the json sch√©ma-recognized field types. That's really what this package is about, lean into it. Some might involve packages in Suggests (eg, don't import clock/lubridate if people don't care about dates, probably something similar for urls). ",
      "comments": {}
    },
    "81": [],
    "82": [],
    "83": [],
    "84": [],
    "85": [],
    "86": [],
    "87": [],
    "88": [],
    "89": [],
    "90": [],
    "91": [],
    "92": [],
    "93": [],
    "94": [],
    "95": [],
    "96": [],
    "97": [],
    "98": [],
    "99": [],
    "100": [],
    "101": [],
    "102": [],
    "103": [],
    "104": {
      "title": "Stabilize dates",
      "type": {},
      "milestone": 5,
      "body": "Add `to_date()` etc. Will probably use `base::as.Date()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": {}
    },
    "105": {
      "title": "Stabilize date-times",
      "type": {},
      "milestone": 5,
      "body": "Add `to_dttm()` etc. Will probably use `base::as.POSIXct()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": {}
    },
    "106": [],
    "107": [],
    "108": [],
    "109": [],
    "110": {
      "title": "Implement `stabilize_list()`",
      "type": {},
      "milestone": 5,
      "body": "(Issue created via conversation with a stbl \"expert\" gem on Google Gemini)\n\n## Overview\n\nWe should add a `stabilize_list()` function family (`stabilize_list`, `to_list`, `are_list_ish`, etc.) to `{stbl}`. The primary purpose of this family would be to validate the structure and contents of lists, which is a common requirement for functions that accept complex configuration objects.\n\n## API Design\n\nThe key challenge is creating an API that is both powerful enough to handle complex, nested, and heterogeneous lists, but simple enough that it doesn't require users to write complex wrappers or use non-standard syntax like `quote()`.\n\nThe proposed API distinguishes between checks on the list container and checks on the list elements.\n\n1. Container Checks: Arguments prefixed with a `.` (e.g., `.min_size`, `.allow_named = TRUE`) will apply to the list object itself.\n2. Element Checks: Unprefixed arguments passed via `...` will define the validation rules for the elements within the list. These arguments should accept `purrr`-style anonymous functions (`~ .x`).\n\n## Proposed Syntax\n\n```r\nstabilize_list(\n  x,\n  ..., # Named arguments are purrr-style formulas for named elements\n  .default = NULL, # A default formula for unspecified/unnamed elements\n  .min_size = NULL,\n  .max_size = NULL\n  # ... other potential container checks\n)\n```\n\n## Concrete Use Case\n\nA function that builds a plot specification could use `stabilize_list` to validate its main argument:\n\n```r\ncreate_plot_spec <- function(spec) {\n  spec <- stabilize_list(\n    spec,\n    # --- Schema for list elements (using formulas) ---\n    title = ~ stabilize_chr_scalar(.x, allow_null = FALSE),\n    data = ~ stabilize_arg(.x, allow_null = FALSE),\n    aesthetics = ~ stabilize_list(\n      .x,\n      x = ~ stabilize_chr_scalar(.x),\n      y = ~ stabilize_chr_scalar(.x),\n      .min_size = 2,\n      .max_size = 2\n    ),\n    # --- Rules for the list container itself ---\n    .min_size = 3,\n    .max_size = 3\n  )\n\n  # ... function logic now operates on a guaranteed-valid spec object ...\n  return(spec)\n}\n```\n\n## Acceptance Criteria\n\n- Create the `stabilize_list` function family with corresponding `to_list` and `are_list_ish` functions and tests.\n- The implementation must support validation of both homogeneous and heterogeneous lists via the formula syntax.\n- The implementation must support both named and unnamed lists.\n- Error messages must be informative, clearly indicating which element of which list failed validation and providing the underlying error from the specific stabilizer that failed.\n",
      "comments": {}
    },
    "111": [],
    "112": [],
    "113": [],
    "114": [],
    "115": [],
    "116": [],
    "117": [],
    "118": [],
    "119": [],
    "120": [],
    "121": [],
    "122": [],
    "123": [],
    "124": [],
    "125": [],
    "126": [],
    "127": [],
    "128": {
      "title": "Ensure `are_*_ish()` and `to_*()` are consistent",
      "type": {
        "id": 20894812,
        "node_id": "IT_kwDOCPuMJs4BPtRc",
        "name": "Bug",
        "description": "An unexpected problem or behavior",
        "color": "red",
        "created_at": "2024-02-20T11:21:46Z",
        "updated_at": "2024-07-26T15:33:07Z",
        "is_enabled": true
      },
      "milestone": 4,
      "body": "Currently, the `are_*_ish()` and `to_*()` function families have some different ideas about what is coercible to a given type.\n\nFor example, `to_chr(list(list(\"a\")))` successfully unnests the lists to produce `\"a\"`, but `are_chr_ish(list(list(\"a\")))` returns `FALSE`.\n\nWe should review the logic in the `are_*_ish()` function family to ensure it is consistent with the `to_*()` family. A developer should be able to use an `are_*_ish()` function to check if a `to_*()` function will succeed.\n\nThis will involve making the `are_*_ish()` functions more permissive (e.g., allowing for list unnesting) to match the behavior of the `to_*()` functions. We should also review for other potential inconsistencies between the two families.\n",
      "comments": {}
    },
    "129": {
      "title": "Rename `to_null()` to `.to_null()`",
      "type": {
        "id": 20894812,
        "node_id": "IT_kwDOCPuMJs4BPtRc",
        "name": "Bug",
        "description": "An unexpected problem or behavior",
        "color": "red",
        "created_at": "2024-02-20T11:21:46Z",
        "updated_at": "2024-07-26T15:33:07Z",
        "is_enabled": true
      },
      "milestone": 4,
      "body": "The `to_null()` function is not exported, so it should be prefixed with a `.` to indicate that it is an internal function, following the package's style guide.",
      "comments": {}
    }
  }
}
